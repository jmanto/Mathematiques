[{"name": "app.py", "content": "import numpy as np\n\nimport matplotlib.pyplot as plt\nfrom matplotlib.patches import Circle, FancyArrowPatch\nimport matplotlib.lines as lines\n\nfrom scipy.integrate import quad, quadrature\n\nfrom shiny import App, render, ui\nfrom shinyswatch.theme import flatly as shiny_theme # sandstone\n\n###################################################################\n# D\u00e9finition des couleurs\n###################################################################\n\nbleu = \"#00B0F0\" # Bleu clair (position) {0, 176, 240}\nvert = \"#00B050\" # Vert (vitesse) {0, 176, 80}\njaune = \"#FFC000\" # Jaune (acc\u00e9l\u00e9ration) {255, 192, 0}\nbordeaux = \"#C00000\" # Bordeaux (force) {192, 0, 0}\nviolet = \"#7030A0\" # Violet (acc\u00e9l\u00e9ration, moment de force) {112, 48, 160}\nvieuxrose = \"#D96180\" # Vieux rose (fonction d'onde) {217, 97, 128}\nbleufonc\u00e9 = \"#0070C0\" # Bleu fonc\u00e9 (\u00e9nergie potentielle) {0, 112, 192}\nvertclair = \"#92d050\" # Vert clair, quantit\u00e9 de mouvement, moment cin\u00e9tique {146, 208, 80}\n\n###################################################################\n# D\u00e9finition des tailles de polices\n###################################################################\n\ninch_per_cm = 1 / 2.54\nfigsize_halfcolumn = (32 * inch_per_cm, 18 * inch_per_cm)\n\nparams = {\n    'figure.figsize': figsize_halfcolumn,\n    'figure.dpi': 100,\n    'legend.fontsize': 16,\n    'axes.labelsize': 16,\n    'axes.titlesize': 16,\n    'xtick.labelsize':12,\n    'ytick.labelsize':12}\n\nplt.rcParams.update(params)\n\n###################################################################\n# Constantes physiques\n###################################################################\n\nG_newton = 6.67E-11 # N m**2/kg**2, constante de la gravitation universelle\n\ne0 = 8.854182E-12 # F/m, permittivit\u00e9 di\u00e9lectrique du vide\nmu0 = 4 * np.pi * 1E-7 # N/A**2, permittivit\u00e9 magn\u00e9tique du vide\nc_vide = 299792458 # m/s, vitesse de la lumi\u00e8re dans le vide\nr_bohr = 5.291772E-11 # m, rayon de Bohr\n\nk_b = 1.380649E-23 # J/K, constante de Bolzmann\nN_Avo = 6.02214076E23 # 1/mol, constante d'Avogadro\nR_gp = 8.31 # J/(K mol), constante des gaz parfaits\natm = 101325 # Pa, atmosph\u00e8re standard\n\nh_planck = 6.62607015E-34 # J/s, constante de Planck (non r\u00e9duite)\nh_bar = 6.62607015E-34 / (2 * np.pi) # J/s, constante de Planck r\u00e9duite\n\nsigma_sb = 5.67E-8 # W / (m**2 T**4), constante de Stefan-Bolzmann\nl_wien = 2.897771955E-3 # m/K, constante de Wien (loi de d\u00e9placement)\n\n# Valeurs standards\ng_terre = 9.81 # m/s**2, acc\u00e9l\u00e9ration de la pesanteur terrestre\np_std = 101325 # Pa, atmosph\u00e8re standard\n\n# Particules \u00e9l\u00e9mentaires\nq_elem = 1.602E-19 # C, charge \u00e9l\u00e9mentaire\nm_e = 9.109E-31 # kg, masse de l'\u00e9lectron\nm_p = 1.673E-27 # kg, masse du proton\nm_n = 1.674E-27 # kg, masse du neutron\numau = 1.661E-27 # kg, unit\u00e9 de masse atomique unifi\u00e9e\n\n# Syst\u00e8me Solaire\nMSoleil = 1.988E30 # kg, masse du Soleil\nMTerre = 5.972E24 # kg, masse de la Terre\nMLune = 7.342E22 # kg, masse de la Lune\n\nRTerre = 6378.1 * 1000 # m (rayon \u00e9quatorial de la Terre)\nRSoleil = 696342 * 1000 # m (rayon \u00e9quatorial du Soleil)\nRLune = 1737.4 * 1000 # m (rayon \u00e9quatorial de la Lune)\n\nname_p = [\"Mercure\", \"V\u00e9nus\", \"Terre\", \"Mars\", \"Jupiter\", \"Saturne\", \"Uranus\", \"Neptune\", \"Pluton\"]\nRp_obs = 1E6 * np.array([58, 108, 150, 228, 778, 1426, 2870, 4498, 5906]) # km, rayon moyen de l'orbite\nTp_obs = np.array([88, 225, 365, 687, 4335, 10758, 30687, 60225, 90553]) # jours, p\u00e9riode de r\u00e9volution\n\n# Conversion degr\u00e9-radian\npi = np.pi\nDEG = pi / 180 # alpha = 60 DEG: on entre la valeur de 60(\u00b0), qui est convertie en radians\nRAD = 180 / pi\n\n\n# D\u00e9finition de fonction pour la d\u00e9riv\u00e9e et l'int\u00e9grale\ndef f(x):\n    return 3 * x**3 + 2 * x**2 - 4 * x + 15\n\ndef fp(x):\n    return 9 * x**2 + 4 * x - 4\n\n# D\u00e9finition de fonction pour la transform\u00e9e de Fourier\ndef g(x, T, fct):\n    x = x % T\n    if fct==\"Triangle\":\n        return 0.5 * x\n    elif fct==\"Carr\u00e9\":\n        return x - x % (T / 2)\n    else:\n        return np.sin(0.5 * x**2 - 2 * x) + 1.5\n\ndef accroissement(x0, dx):\n    x = np.array([x0, x0 + dx])\n    y = f(x)\n\n    return (y[1] - y[0]) / (x[1] - x[0])    \n\ndef derive(x0, dx, axs, dL=1):\n    x = np.array([x0, x0 + dx])\n    y = f(x)\n    dy = y[1] - y[0]\n\n    # Prolongement du segment de droite reliant les deux points\n    xseg = np.array([x[0] - dL, x[1] + dL])\n    yseg = np.array([y[0] - dL * dy / dx, y[1] + dL * dy / dx])\n\n    axs.scatter(x, y, color=\"b\", s=20)\n    axs.plot(xseg, yseg, color=\"k\")\n    axs.vlines(x=x[1], ymin=y[1], ymax=y[0], color=\"k\", lw=1, ls=\"--\")\n    axs.hlines(y=y[0], xmin=x[1], xmax=x[0], color=\"k\", lw=1, ls=\"--\")\n\n\ndef integre(xi, xf, n, axs, showPts=True, showEdge=None):\n    x = np.linspace(xi, xf, n + 1, endpoint=True)\n    y = f(x)\n    width = (xf - xi) / (n)\n\n\n    if showPts:\n        axs.scatter(x, y, color=\"b\", s=20)\n    \n    for xi, yi in zip(x[:-1], y[:-1]):\n        axs.add_patch(plt.Rectangle((xi, yi), width, -yi, facecolor='b',\n                    edgecolor=showEdge, alpha=0.5))\n\ndef coef_anbn(n, T, fct):\n    if n==0:\n        an = 1 / T * quadrature(lambda t: g(t, T, fct), 0, T)[0]\n        bn = 0\n    else:\n        an = 2 / T * quadrature(lambda t: g(t, T, fct) * np.cos(2 * pi * n * t / T), 0, T)[0]\n        bn = 2 / T * quadrature(lambda t: g(t, T, fct) * np.sin(2 * pi * n * t / T), 0, T)[0]\n\n    return an, bn       \n\n# Define the UI\napp_ui = ui.page_navbar(\n    ui.nav_spacer(),  # Elements r\u00e9partis depuis la droite\n    ui.nav_panel(\"Vecteurs\".upper(),\n        ui.layout_columns(\n            ui.card(\"Param\u00e8tres\".upper(),\n                ui.input_slider(\"A\", \"Amplitude\", min=0, max=2, value=1, step=0.2),\n                ui.input_slider(\"w\", \"Pulsation\", min=0, max=10, value=1, step=0.2),\n                ui.input_slider(\"phi0\", \"Phase initiale\", min=0, max=2 * pi, value=0, step=2 * pi / 10),\n            ),\n            ui.card(\"R\u00e9sultats\".upper(),\n                ui.output_plot(\"plotCosinus\")\n            ),\n            col_widths=(2, 10),\n        ),     \n    ),\n    ui.nav_panel(\"D\u00e9riv\u00e9es\".upper(),\n        ui.layout_columns(\n            ui.card(\"Param\u00e8tres\".upper(),\n                ui.input_slider(\"x0\", \"x0\", min=-2, max=2, value=1, step=0.2),\n                ui.input_slider(\"dx\", \"Accroissement selon x\", min=0.05, max=1, value=1, step=0.05),\n                ui.input_switch(\"showDerive\", \"Afficher la d\u00e9riv\u00e9e\", value=False)\n            ),\n            ui.card(\"R\u00e9sultats\".upper(),\n                ui.output_plot(\"plotDerive\")\n            ),\n            col_widths=(2, 10),\n        ),     \n    ),\n    ui.nav_panel(\"Int\u00e9grales\".upper(),\n        ui.layout_columns(\n            ui.card(\"Param\u00e8tres\".upper(),\n                ui.input_slider(\"n\", \"Nombre de segments\", min=1, max=200, value=1),\n                ui.div(style=\"padding-bottom: 500px\"),\n            ),\n            ui.card(\"R\u00e9sultats\".upper(),\n                ui.output_plot(\"plotIntegre\")\n            ),\n            col_widths=(2, 10),\n        ),     \n    ),\n    ui.nav_panel(\"S\u00e9rie de Fourier\".upper(),\n        ui.layout_columns(\n            ui.card(\"Param\u00e8tres\".upper(),\n                ui.input_select(\"fct\", \"Fonction\", [\"Carr\u00e9\", \"Triangle\", \"G\u00e9n\u00e9rale\"]),\n                ui.input_slider(\"nmax\", \"Nombre de termes\", min=0, max=10, value=0),\n                ui.input_switch(\"showPartial\", \"Afficher les harmoniques\", value=False),\n                ui.div(style=\"padding-bottom: 500px\"),\n            ),\n            ui.card(\"R\u00e9sultats\".upper(),\n                ui.output_plot(\"plotFourier\")\n            ),\n            col_widths=(2, 10),\n        ),     \n    ),\n    title=\"Math\u00e9matique\".upper(),\n    theme=shiny_theme,\n)\n\n# Define the server logic\ndef server(input, output, session):\n    @output\n\n    @render.plot()\n    def plotCosinus():\n        fig, axs = plt.subplots(1, 1)\n\n        t = np.linspace(0, 2 * pi, 100)\n        f = input.A() * np.cos(input.w() * t + input.phi0())\n\n        axs.plot(t, f, color=bleufonc\u00e9, linewidth=2)\n        axs.hlines(xmin=0, xmax=2 * pi, y=0, color=\"k\", linewidth=1)\n        \n        axs.set_xlim(0, 2 * pi)\n        axs.set_ylim(-2.2, 2.2)\n\n        axs.set_xlabel(\"Temps (s)\")\n        axs.set_ylabel(\"f\")\n        \n        return fig\n\n    @render.plot()\n    def plotDerive():\n        fig, axs = plt.subplots(1, 2)\n\n        x = np.linspace(-2, 2, 300)\n        y = f(x)\n        \n        axs[0].plot(x, y)\n\n        if input.showDerive():\n            yp = fp(x)\n            axs[0].plot(x, yp)\n\n        derive(input.x0(), input.dx(), axs[0])\n\n        axs[0].set_xlabel(\"x\")\n        axs[0].set_ylabel(\"f(x), f'(x)\")\n        axs[0].set_xlim(-2.5, 2.5)\n        axs[0].set_ylim(-5, 45)\n\n        dx = np.linspace(0.01, 1, 100)\n        dy = np.zeros_like(dx)\n\n        for i, dxi in enumerate(dx):\n            dy[i] = accroissement(input.x0(), dxi)\n\n        axs[1].plot(dx, dy)\n\n        axs[1].set_xlabel(\"dx\")\n        axs[1].set_xlabel(\"f'(x)\")\n        axs[1].set_xlim(0, 1)\n        #axs[0].set_ylim(0, 45)\n\n        return fig\n\n    @render.plot()\n    def plotIntegre():\n        fig, axs = plt.subplots(1, 1)\n\n        x = np.linspace(-2, 2, 100)\n\n        y = f(x)\n\n        axs.plot(x, y)\n\n        axs.set_xlabel(\"t\")\n        axs.set_ylabel(\"f(t)\")\n        axs.set_xlim(-2.1, 2.1)\n        axs.set_ylim(0, 45)\n\n        n = input.n()\n        if n < 50:\n            showPts = True\n            showEdge = \"k\"\n        else:\n            showPts = False\n            showEdge = None\n\n        integre(-2, 2, input.n(), axs, showPts=showPts, showEdge=showEdge)\n\n        return fig\n\n    @render.plot()\n    def plotFourier():\n        T = 2 * pi\n        fct = input.fct()\n        \n        fig, axs = plt.subplots(1, 2)\n\n        x = np.linspace(0, 3 * T, 300)\n        y = g(x, T, fct)\n        \n        axs[0].plot(x, y, color=bleufonc\u00e9, lw=2)\n\n        nmax = input.nmax() + 1\n\n        g_rec = np.zeros_like(x)\n        a = np.zeros_like(range(nmax)).astype(float)\n        b = np.zeros_like(range(nmax)).astype(float)\n\n        for n in range(nmax):\n            a[n], b[n] = coef_anbn(n, T, fct)\n            g_partiel = a[n] * np.cos(2 * pi * n * x / T) + b[n] * np.sin(2 * pi * n * x / T)\n\n            if input.showPartial():\n                if n > 0:\n                    axs[0].plot(x, g_partiel + a[0], color=vert)\n                else:\n                    axs[0].plot(x, g_partiel, color=vert)\n            else:\n                g_rec = g_rec + a[n] * np.cos(2 * pi * n * x / T) + b[n] * np.sin(2 * pi * n * x / T)\n\n        if not input.showPartial():\n            axs[0].plot(x, g_rec, color=bleu, lw=2, ls=\"--\")\n\n        axs[1].scatter(np.arange(nmax) - 0.2, a, color=bordeaux, label=r\"a$_n$\")\n        axs[1].scatter(np.arange(nmax) + 0.2, b, color=vert, label=r\"b$_n$\")\n        axs[1].vlines(x=np.arange(nmax)- 0.2, ymin=0, ymax=a, color=bordeaux, linewidth=2)    \n        axs[1].vlines(x=np.arange(nmax) + 0.2, ymin=0, ymax=b, color=vert, linewidth=2)\n\n        axs[1].hlines(y=0, xmin=-1, xmax=11, color=\"k\", lw=1)\n\n        axs[0].set_xlabel(\"t\")\n        axs[0].set_ylabel(\"f(t)\")\n        axs[0].set_xlim(0, 3 * T)\n        axs[0].set_ylim(0, 3.5)\n\n        axs[1].set_xlabel(\"n\")\n        axs[1].set_ylabel(r\"a$_n$, b$_n$\")        \n        axs[1].set_xlim(-1, 11)\n        axs[1].set_ylim(-2.5, 2.5)\n        axs[1].legend()\n        axs[1].grid()\n\n        return fig\n    \n# Create the app\napp = App(app_ui, server)\n", "type": "text"}]